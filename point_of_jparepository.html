<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Spring Data JPA 說明</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      line-height: 1.6;
    }
    h1, h2 {
      color: #2c3e50;
    }
    p {
      margin-bottom: 1em;
    }
    code {
      background-color: #f4f4f4;
      padding: 2px 4px;
      border-radius: 4px;
    }
    pre {
      background-color: #f4f4f4;
      padding: 10px;
      border-radius: 4px;
      overflow-x: auto;
    }
    ul {
      margin-left: 20px;
    }
    @media screen and (max-width: 767px) {
      img{
        max-width: 100%;
      }
    }
  </style>
</head>
<body>
<div id="google-translate-box">
  <div id="google_translate_element"></div>
  <!-- Google Translate 的自動翻譯功能 -->
  <script type="text/javascript">
    function googleTranslateElementInit() {
      new google.translate.TranslateElement({
        pageLanguage: 'zh-TW',  // 頁面原語言
        includedLanguages: 'en,es,fr,de,it,zh-CN,ja,ko,th,vi,my,id,ms,ar,he,ru,tg,uk,hi,tr,pt,nl,is,fi,sv,no,ro,kk,bo,mn,la,fil,tl,el',  // 支援的翻譯語言（可擴展）
        layout: google.translate.TranslateElement.InlineLayout.SIMPLE
      }, 'google_translate_element');
    }
  </script>
  <script type="text/javascript" src="https://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>
  <p>點擊上方的語言選單以切換語言</p>
</div>
<h1>Spring Boot 中的 JpaRepository 簡介</h1>

<p>在 <strong>Spring Boot</strong> 中，透過 <code>JpaRepository</code> 這樣的接口，可以大大簡化資料庫操作的程式碼。這背後的原理是 <strong>Spring Data JPA</strong> 提供了大量的自動生成查詢方法，讓開發者不需要手動撰寫 SQL 或是 JPQL 來執行常見的資料庫操作。</p>

<h2>原理解析</h2>

<h3>1. <code>JpaRepository</code> 的自動實現</h3>
<p><code>JpaRepository</code> 是 <strong>Spring Data JPA</strong> 提供的介面，它繼承自 <code>CrudRepository</code> 和 <code>PagingAndSortingRepository</code>，提供了許多對實體進行 CRUD 操作（如 <code>save()</code>, <code>findById()</code>, <code>delete()</code> 等）的方法。Spring Data JPA 利用 JDK 的動態代理技術，會自動生成這些方法的實作，所以你不需要手動寫這些方法的實現。</p>

<h3>2. 自動生成查詢</h3>
<p>在 <code>StudentRepository</code> 這個範例中：</p>
<ul>
  <li><code>findByEmail(String email)</code>：Spring Data JPA 會自動根據方法名推斷出需要執行的 SQL 查詢，這相當於執行 <code>SELECT * FROM student WHERE email = ?</code>。</li>
  <li><code>findByFirstNameContaining(String name)</code>：這個方法會生成一個查詢，查找學生的 <code>first_name</code> 中包含指定字串的記錄，實際的 SQL 查詢是類似 <code>SELECT * FROM student WHERE first_name LIKE %?%</code>。</li>
</ul>

<p>Spring Data JPA 根據方法名的命名規則自動生成對應的 SQL 查詢，這樣開發者就不需要手動寫 SQL 或 JPQL 查詢語句了。</p>

<h3>3. 自動注入的 Repository</h3>
<p>在 <strong>Spring Boot</strong> 中，<code>StudentRepository</code> 會被自動註冊為 Spring 的 Bean，並且通過 <code>@Autowired</code> 或是構造函數注入的方式，將其注入到對應的 service 層中。這樣，當你在 service 層中呼叫 <code>studentRepository.findByEmail("test@example.com")</code> 時，Spring Data JPA 會自動處理資料庫查詢的部分。</p>

<h3>4. 省去的繁瑣步驟</h3>
<ul>
  <li>不需要手動編寫 SQL 查詢。</li>
  <li>不需要處理資料庫連接、關閉連接等細節，這些都由 Spring Data JPA 自動管理。</li>
  <li>不需要處理常見的 CRUD 操作，只要定義好接口方法即可。</li>
</ul>

<h2>範例操作流程</h2>

<h3>1. <code>Repository</code> 定義</h3>
<p>你在 <code>StudentRepository</code> 中定義了查詢方法（例如 <code>findByEmail</code> 和 <code>findByFirstNameContaining</code>），這些方法會被自動解析成 SQL 查詢語句。</p>

<h3>2. <code>Service</code> 層調用</h3>
<p>在 <code>Service</code> 層，通過注入 <code>StudentRepository</code>，你可以直接調用這些方法來獲取資料，而不需要編寫額外的資料庫查詢代碼。例如：</p>

<pre>
<code>
@Service
public class StudentService {

    @Autowired
    private StudentRepository studentRepository;

    public Student getStudentByEmail(String email) {
        return studentRepository.findByEmail(email);
    }

    public List<Student> searchStudentsByName(String name) {
        return studentRepository.findByFirstNameContaining(name);
    }
}
</code>
</pre>

<h3>3. Spring 自動化處理</h3>
<p>Spring Boot 會根據 <code>findByEmail</code> 和 <code>findByFirstNameContaining</code> 方法名自動生成對應的查詢語句，並處理資料庫交互的部分。你只需要關注業務邏輯，而不需要處理低層次的 SQL 操作。</p>

<h2>小結</h2>
<p><strong>Spring Data JPA</strong> 的核心是通過約定優於配置（convention over configuration）的方式，簡化了資料庫操作。只要定義好接口方法名稱，Spring Data JPA 就能自動推導出相應的查詢邏輯，這樣你就不需要手動編寫繁瑣的 SQL 或 JPA 查詢語句。這樣不僅提升開發效率，還減少了錯誤的發生機率。</p>
<footer style="text-align: center; background-color: purple; color:yellow; font-size: 50px">
  作者：<a href="https://www.facebook.com/profile.php?id=100056441813114&locale=zh_TW" target="_blank" style="color:white;">周彥廷</a>
  <br>創作日期：西元二零二五年八月二十一日<br>
  <img width="324" height="432" src="my_appearance2.jpg" alt="自拍">
  <br>
</footer>
<div id="fb-root"></div>
<script async defer crossorigin="anonymous"
        src="https://connect.facebook.net/zh_TW/sdk.js#xfbml=1&version=v17.0" nonce="yourNonce">
</script>

<div class="fb-comments"
     data-href="https://chrischou19990904.github.io/harp_app_introduction"
     data-width="100%"
     data-numposts="5">
</div>


<script>
  document.getElementById('comment-form').addEventListener('submit', function (e) {
    e.preventDefault();

    const name = document.getElementById('name').value.trim();
    const message = document.getElementById('message').value.trim();
    const imageFile = document.getElementById('image').files[0];
    const videoFile = document.getElementById('video').files[0];

    if (!name || !message) {
      alert('請填寫名字和留言內容');
      return;
    }

    const commentDiv = document.createElement('div');
    commentDiv.innerHTML = `<p><strong>${name}</strong>: ${message}</p>`;

    const mediaWrapper = document.createElement('div');
    mediaWrapper.classList.add('media-wrapper');

    if (imageFile) {
      const img = document.createElement('img');
      img.src = URL.createObjectURL(imageFile);
      img.alt = '上傳的圖片';
      mediaWrapper.appendChild(img);
    }

    if (videoFile) {
      const video = document.createElement('video');
      video.src = URL.createObjectURL(videoFile);
      video.controls = true;
      mediaWrapper.appendChild(video);
    }

    // 只有當有圖片或影片時才加 mediaWrapper
    if (mediaWrapper.children.length > 0) {
      commentDiv.appendChild(mediaWrapper);
    }

    document.getElementById('comments').appendChild(commentDiv);

    this.reset();
  });
</script>
<ul id="messages"></ul>
</body>
</html>
